#!/usr/bin/python3

import hashlib
import os
import argparse
from typing import List, Optional, Union
from PIL import Image
import numpy as np

from toolbox.subcommands.loader import register
from toolbox.logger import console


Pixels = np.ndarray[tuple[int, ...]]
Indices = np.ndarray[tuple[int, ...]]


class ScrambleKey:
    """The scramble key converts a password into a seemingly randomized list of indices used to
    re-order 2d arrays.
    """

    size = 128

    def __init__(self, key_data: Union[bytes, str]) -> None:
        if isinstance(key_data, str):
            key_data = key_data.encode("utf8")
        self._bytes = [i & 0xFF for i in hashlib.sha256(key_data).digest()]  # 32 bytes
        self.init()

    def init(self) -> None:
        """
        Initialize a 2d array of indices from a sequence generated by the key bytes
        Scramble the 2d array of indices to create a randomized list of max_length ** 2 indices
        """
        self._sequence = self._get_sequence()  # randomized list if indices
        self._arr = np.arange(self.size**2).reshape(
            (self.size, self.size)
        )  # sequential matrix
        self._arr = do_mod(self._arr, self._sequence)  # scrambled matrix

    def _get_sequence(self) -> Indices:
        """
        Randomize a sequential list of indices based on the key bytes
        We can generate any length array based on the limited number of bytes in the key
        """

        out: List[np.uint32] = []
        arr: List[np.uint32] = list(np.arange(self.size, dtype=np.uint32))

        for rot in range(0, 8, 2):
            for b in self._bytes:
                idx = self._bit_rot(b, rot) % len(arr)
                out.append(arr.pop(idx))

        return np.array(out)

    @staticmethod
    def _bit_rot(byte: int, shift: int) -> int:
        n1 = byte >> (8 - shift)
        n2 = (byte << shift) & 0xFF
        return n1 | n2

    @property
    def array(self):
        return self._arr.flatten()


def load_image(filename: str) -> Pixels:
    img = Image.open(filename)
    return np.array(img)


def save_image(arr: np.ndarray, filename: str, fmt: str="PNG") -> None:
    """Save the pixel array to a file.
    """
    data = Image.fromarray(arr)
    data.save(filename, format=fmt)
    console.log(f"Saved [green]{filename}[/green]")


def do_mod(pixel_array: np.ndarray, key: np.ndarray, do_scramble: bool=True):

    def rotate_cw(array: np.ndarray) -> np.ndarray:
        return np.rot90(array, k=3)

    def rotate_ccw(array: np.ndarray) -> np.ndarray:
        return np.rot90(array, k=1)

    def slant(array: np.ndarray) -> np.ndarray:
        # width / height to determine the ratio for slanting evenly
        diff = float(array.shape[1]) / array.shape[0]
        incr = 0
        r = diff if not do_scramble else -diff
        print("Roll:", r)
        for i, row in enumerate(array):
            roll = int(-incr if do_scramble else incr)
            array[i] = np.roll(row, roll, 0)
            incr += diff
            r = incr
        print("Roll:", r)
        return array

    def scramble(array: np.ndarray):
        if do_scramble:
            return array[key[key < array.shape[0]]]
        
        out = np.copy(array)
        for i, out_index in enumerate(key[key < array.shape[0]]):
            out[out_index] = array[i]
        return out

    processes = [
        scramble,
        slant,
        scramble,
        rotate_cw,
        scramble,
        slant,
        scramble,
        rotate_ccw,
        scramble,
        slant,
        scramble,
    ]

    for process in processes:
        pixel_array = process(pixel_array)

    return pixel_array


def update_filename(filename: str, new_ext: str="png", new_dir: Optional[str]=None, suffix: Optional[str]=None):
    new_dir = new_dir or os.path.dirname(filename)
    basename = os.path.basename(filename)

    filename_only = ".".join(basename.split(".")[:-1])
    new_file = (
        f"{filename_only}-{suffix}.{new_ext}"
        if suffix is not None
        else f"{filename_only}.{new_ext}"
    )

    return os.path.join(new_dir, new_file)


def main(
    password: str,
    file_paths: List[str],
    do_scramble: bool,
    out_dir: str,
    out_format: str,
) -> None:
    key = ScrambleKey(password or b"").array

    op = "Scrambling" if do_scramble else "Unscrambling"
    with console.status(op) as status:
        for filename in file_paths:
            assert os.path.exists(filename), f"{filename} does not exist"
            assert os.path.isfile(filename), "File path must be an image file"

            pixel_array = load_image(filename)
            status.update(f"{op} [green]{filename}[/green]")
            enc = do_mod(pixel_array, key, do_scramble=do_scramble)
            new_ext = "png" if out_format == "PNG" else "jpg"
            out_dir = out_dir or os.path.dirname(filename)
            out_file = os.path.join(out_dir, os.path.basename(filename))
            out_file, _ = os.path.splitext(out_file)
            out_file = f"{out_file}.{new_ext}"

            # save the new file
            save_image(enc, out_file, fmt=out_format)


@register("scramble", description="Pixel scramble an image")
def setup_parser(parser: argparse.ArgumentParser) -> None:
    default_password = os.environ.get("SCRAMBLE_PASSWORD")

    parser.add_argument("file_paths", nargs="+", help="File path(s) to images")
    parser.add_argument(
        "--password",
        "-p",
        default=default_password,
        help="The password to use to scramble, defaults to environment variable SCRAMBLE_PASSWORD",
    )
    parser.add_argument(
        "--unscramble",
        "-u",
        action="store_false",
        dest="do_scramble",
        help="Whether to unscramble instead of scramble",
    )
    parser.add_argument(
        "--out-dir", default=None, help="The directory to save the resulting file to"
    )
    parser.add_argument(
        "--out-format",
        "-f",
        choices=["PNG", "JPEG"],
        default="PNG",
        help="Store the resulting file in this format",
    )
    parser.set_defaults(func=main)
